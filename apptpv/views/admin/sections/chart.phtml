<section id="chart">
    <?php
    new MenuSquare([
        'tile' => 'Gráfica ingresos dia',
        'content' => '<canvas id="chartDays" width="600px" height="600px"></canvas>'
    ]);

    new MenuSquare([
        'tile' => 'Gráfica ingresos mes',
        'content' => '<canvas id="chartMonth" width="400px" height="400px"></canvas>'
    ]);
    new MenuSquare([
        'tile' => 'Gráfica ingresos años',
        'content' => '<canvas id="chartYear" width="400px" height="400px"></canvas>'
    ]);
    ?>
    <script>
        app.chart = {
            color: {
                current: {
                    body: 'rgba(40, 184, 53, 0.41)',
                    border: 'rgba(40, 184, 53, 0.61)',
                },
                predict: {
                    body: 'rgba(88, 88, 88, 0.21)',
                    border: 'rgba(88, 88, 88, 0.31)',
                }
            },
            buttons: [],
            load() {
                app.post({
                    controller: 'tickets',
                    action: 'getAll',
                    data: null
                }, async data => {

                    // Preparamos los datos
                    const ordata = this.prepare(data)
                    // Totalizamos los dias 
                    const daydata = this.groupDataDays(ordata)
                    // Convertimos las propiedades en arrays 
                    const arrdaydata = this.toArrays(daydata)
                    // Crea grafica dias
                    this.create('chartDays', arrdaydata, 'Ingresos Dias');

                    // Crea grafica agrupacion por meses
                    this.create(
                        'chartMonth',
                        this.toArrays(this.groupDataMonths(ordata)),
                        'Ingresos Mes')
                    // Crea grafica agrupacion por años
                    this.create(
                        'chartYear',
                        this.toArrays(this.groupDataYears(ordata)),
                        'Ingresos Mes')

                })
            },
            // Crea un array de objetos para poder tratar los datos
            prepare(data) {
                const ordata = []

                // Se ordena el array por fecha                       
                data.sort(function(a, b) {
                    dateA = date.sql(a.fecha)
                    dateB = date.sql(b.fecha)
                    return new Date(dateA) - new Date(dateB);
                });

                // Ponemos los datos en un array
                for (const i in data) {
                    const d = data[i]
                    if (d) {
                        const
                            dt = +new Date(date.sql(d.fecha)).getTime(),
                            ts = Math.floor(dt / 1000);

                        ordata.push({
                            id: i,
                            date: date.short(d.fecha),
                            hour: date.hour(d.fecha),
                            value: d.total,
                            timestamp: ts
                        })
                    }
                }
                return ordata;
            },
            groupDataDays(array) {
                return this.groupData(array, 0)
            },
            groupDataMonths(array) {
                return this.groupData(array, 3)
            },
            groupDataYears(array) {
                return this.groupData(array, 6)
            },
            groupData(array, slice) {
                return array.reduce(function(groups, item, index) {
                    const i = item['date'].slice(slice)
                    groups[i] = groups[i] || {
                        date: i,
                        value: 0,
                        count: 0,
                        timestamp: 0,
                    };

                    groups[i].value += item.value;
                    groups[i].count = index;
                    groups[i].timestamp = item.timestamp;

                    return groups;
                }, {});
            },
            // Crea un gráfico
            async create(name, data, labelBar, color = null, borderColor = null) {


                const
                    colorBars = [],
                    colorBorders = [],
                    el = document.getElementById(name)

                for (let i in data[0]) {
                    colorBars.push(color || this.color.current.body)
                    colorBorders.push(borderColor || this.color.current.border)
                }
                // Gráfica
                const
                    chart = new Chart(el, {
                        type: 'bar',
                        data: {
                            labels: data[3],
                            datasets: [{
                                label: labelBar,
                                data: data[1],
                                backgroundColor: colorBars,
                                borderColor: colorBorders,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: false,
                            scales: {
                                yAxes: [{
                                    ticks: {
                                        beginAtZero: true
                                    }
                                }]
                            }
                        }
                    })
                // Predicciones
                const
                    date = new Date(data[0][data[0].length - 1] * 1000)

                date.setDate(date.getDate() + 1)
                const
                    dt = date.getTime(),
                    ts = Math.floor(dt / 1000);

                const pred = Math.max(...data[2]) + 1
                const y = await this.learnLinear(data, pred);
                echo(y)
                this.addData(chart, 'previsión', y.toFixed(2));
                return chart;
            },
            // Añade datos a la grafica
            addData(chart, label, data) {
                chart.data.labels.push(label);
                chart.data.datasets.forEach((dataset) => {
                    dataset.data.push(data);
                    dataset.backgroundColor.push(this.color.predict.body);
                    dataset.borderColor.push(this.color.predict.border);
                });
                chart.update();
            },
            toArrays(obj) {
                const o = Object.values(obj),
                    a = [],
                    b = [],
                    c = [],
                    d = [];

                for (const p of o) {
                    a.push(p.timestamp)
                    b.push(p.value)
                    c.push(p.count)
                    d.push(p.date)
                }
                return [a, b, c, d]
            },
            //Creamos una funcion asincrona (para que se active hasta que termine de cargar la pagina)
            async learnLinear(val, newVal) {
                //Definimos el modelo que sera de regresion lineal
                const batchSize = 32;
                const epochs = 100;
                const model = tf.sequential();
                // Add a single hidden layer
                model.add(tf.layers.dense({
                    inputShape: [1],
                    units: 1,
                    useBias: true
                }));
                //Agregamos una capa densa porque todos los nodos estan conectado entre si
                model.add(tf.layers.dense({
                    units: 1,
                    useBias: true
                }));

                // Compilamos el modelo con un sistema de perdida de cuadratico y optimizamos con sdg
                model.compile({
                    loss: tf.losses.meanSquaredError,
                    optimizer: tf.train.adam(),
                    metrics: ['mse'],
                });

                // Creamos los tensores para x y para y

                const inputs = tf.tensor2d(val[2], [val[0].length, 1], 'float32');
                const labels = tf.tensor2d(val[1], [val[0].length, 1], 'float32');

                // entrenamos 
                await model.fit(inputs, labels, {
                    batchSize,
                    epochs,
                    shuffle: true,
                });
                // Predicción

                return model.predict(tf.tensor2d([newVal], [1, 1])).dataSync()[0];
            },
            groupformonth(array) {
                // Construcción del nuevo array:

                const resultado = [],
                    months = [],
                    totals = [];
                array.reduce(function(res, value) {
                    // Creamos la posición del array para cada mes
                    let mes = new Date(date.sql(value.date)).getMonth() + 1;

                    if (!res[mes]) {
                        res[mes] = {
                            month: mes
                        };

                        // Inicializamos a 0 el valor de cada key
                        Object.keys(value).forEach(function(key) {
                            if (key != 'date') {
                                res[mes][key] = 0;
                            }
                        })
                        resultado.push(res[mes])
                    }

                    // Sumamos el valor de cada clave dentro de un bucle
                    Object.keys(value).forEach(function(key) {
                        if (key != 'fecha') {
                            res[mes][key] += value[key];
                        }
                    })
                    return res;
                }, {});

                return this.twoArrays(resultado, 'month', 'value')
            },
        };
    </script>
</section>