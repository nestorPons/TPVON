<section id="chart">
    <?php
    new MenuSquare([
        'tile' => 'Gráfica ingresos dia',
        'content' => '<canvas id="chartDays" width="600px" height="600px"></canvas>'
    ])
    ?>
    <?php
    new MenuSquare([
        'tile' => 'Gráfica ingresos mes',
        'content' => '<canvas id="chartMonth" width="400px" height="400px"></canvas>'
    ])
    ?>
    <script>
        app.chart = {
            color: {
                current: {
                    body: 'rgba(40, 184, 53, 0.41)',
                    border: 'rgba(40, 184, 53, 0.61)',
                },
                predict: {
                    body: 'rgba(88, 88, 88, 0.21)',
                    border: 'rgba(88, 88, 88, 0.31)',
                }
            },
            buttons: [],
            load() {
                app.post({
                    controller: 'tickets',
                    action: 'getAll',
                    data: null
                }, async data => {
                    // Agrupa los datos por meses
                    const arr = [],
                        labels = [],
                        datas = [];

                    // Ponemos los datos en un array
                    for (const i in data) {
                        const d = data[i]
                        if (d) {
                            const k = date.short(d.fecha)
                            if (arr[k] != undefined) arr[k] += d.total
                            else arr[k] = d.total
                        }
                    }
AKI :: solucionar problema grafico por dias
                    // Se ordena el array por fecha
                    // Se dividen los datos en dos arrays
                    const
                        dOrder = this.orderDataByDate(arr),
                        daysXY = this.twoArrays(dOrder, 'date', 'value');

                    // Crea grafica dias
                    this.create('chartDays', daysXY, 'Ingresos Dias', 'rgba(40, 184, 53, 0.41)', 'rgba(40, 184, 53, 0.61)')
                    
                    // Se agrupa los datos por meses
                    let dataMonth = await this.groupformonth(dOrder)
                    // Crear grafica mes
                    this.create('chartMonth', dataMonth, 'Ingresos Mes', 'rgba(40, 184, 53, 0.41)', 'rgba(40, 184, 53, 0.61)')

                })
            },
            // Crea un gráfico
            async create(name, data, labelBar, color, borderColor) {

                const
                    colorBars = [],
                    colorBorders = [],
                    el = document.getElementById(name)

                for (let i in data[0]) {
                    colorBars.push(color)
                    colorBorders.push(borderColor)
                }
                // Gráfica
                const
                    chart = new Chart(el, {
                        type: 'bar',
                        data: {
                            labels: data[0],
                            datasets: [{
                                label: labelBar,
                                data: data[1],
                                backgroundColor: colorBars,
                                borderColor: colorBorders,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: false,
                            scales: {
                                yAxes: [{
                                    ticks: {
                                        beginAtZero: true
                                    }
                                }]
                            }
                        }
                    })
                // Predicciones

                const y = await this.learnLinear(data, data[1].length);

                this.addData(chart, 'previsión', y);
                return chart;
            },
            // Añade datos a la grafica
            addData(chart, label, data) {
                chart.data.labels.push(label);
                chart.data.datasets.forEach((dataset) => {
                    dataset.data.push(data);
                    dataset.backgroundColor.push(this.color.predict.body);
                    dataset.borderColor.push(this.color.predict.border);
                });
                chart.update();
            },
            twoArrays(obj, prop1, prop2) {
                const a = [],
                    b = [];
                for (const i in obj) {
                    a.push(obj[i][prop1])
                    b.push(obj[i][prop2])
                }
                return [a, b]
            },
            //Creamos una funcion asincrona (para que se active hasta que termine de cargar la pagina)
            async learnLinear(val, newVal) {

                //Definimos el modelo que sera de regresion lineal
                const epochs = 50;
                const model = tf.sequential();
                //Agregamos una capa densa porque todos los nodos estan conectado entre si
                model.add(tf.layers.dense({
                    units: 1,
                    inputShape: [1]
                }));

                // Compilamos el modelo con un sistema de perdida de cuadratico y optimizamos con sdg
                model.compile({
                    loss: 'meanSquaredError',
                    optimizer: 'sgd'
                });

                // Creamos los tensores para x y para y
                const xs = tf.tensor2d(val[0], [val[0].length, 1], 'float32');
                const ys = tf.tensor2d(val[1], [val[1].length, 1], 'float32');

                // entrenamos 
                await model.fit(xs, ys, {
                    epochs: epochs
                });
                // Predicción

                return model.predict(tf.tensor2d([newVal], [1, 1])).dataSync()[0];
            },
            groupformonth(array) {
                // Construcción del nuevo array:

                const resultado = [],
                    months = [],
                    totals = [];
                array.reduce(function(res, value) {
                    // Creamos la posición del array para cada mes
                    let mes = new Date(date.sql(value.date)).getMonth() + 1;
                        
                    if (!res[mes]) {
                        res[mes] = {
                            month: mes
                        };

                        // Inicializamos a 0 el valor de cada key
                        Object.keys(value).forEach(function(key) {
                            if (key != 'date') {
                                res[mes][key] = 0;
                            }
                        })
                        resultado.push(res[mes])
                    }

                    // Sumamos el valor de cada clave dentro de un bucle
                    Object.keys(value).forEach(function(key) {
                        if (key != 'fecha') {
                            res[mes][key] += value[key];
                        }
                    })
                    return res;
                }, {});

                return this.twoArrays(resultado, 'month', 'value')
            },
            orderDataByDate(arr) {
                // Inicializamos los arrays
                let sortedKeys = new Array();
                let sortedObj = [];

                // Separamos la clave en un solo array
                for (let i in arr) {
                    sortedKeys.push(i);
                }
                // Ordenamos dicha clave
                sortedKeys.sort(function(a, b) {
                    dateA = date.sql(a)
                    dateB = date.sql(b)
                    return new Date(dateA) - new Date(dateB);
                });

                // Reconstruimos el array asociativo con la clave ordenada
                for (let i in sortedKeys) {
                    sortedObj.push({
                        date: sortedKeys[i],
                        value: arr[sortedKeys[i]]
                    })
                }
                return sortedObj;
            },
        };
    </script>
</section>